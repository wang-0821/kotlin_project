* [1.MySQL架构](#1)
* [2.Schema与数据类型优化](#2)
* [3.创建高性能的索引](#3)
* [4.查询性能优化](#4)
* [5.MySQL高级特性](#5)
* [6.MySQL锁](#6)
* [7.MySQL数据页存储与磁盘之间的关系](#7)
* [8.聚合查询](#8)
* [9.MySQL主背同步](#9)
* [10.数据库范式](#10)

<h2 id="1">1.MySQL架构</h2>
&emsp;&emsp; MySQL拥有分层架构，上层是服务器层的服务和查询执行引擎，下层是存储引擎。

                          MySQL服务器逻辑架构
                            连接／线程处理
                             |        |
                             V        V
                          查询缓存<--解析器
                                      |
                                      V
                                    优化器
                                      |
                                      V
                                   存储引擎
<br>
&emsp;&emsp; 通常解决并发读或写时，通过一个由两种类型的锁组成的锁系统来解决问题。这两种锁被称为共享锁(shared xiao.base.lock)、排他锁(exclusive xiao.base.lock)，
也被成为读锁(read xiao.base.lock)和写锁(write xiao.base.lock)。                   

### 表锁
&emsp;&emsp; 表锁是MySQL中最基本的锁策略，是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作时，需要先获得写锁，这会阻塞其他用户
对该表的所有读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不互相阻塞的。写锁拥有比读锁更高的优先级，因此一个写锁请求可能会被插入到
读锁队列的前面。尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种锁实现不同的目的，如服务器会为ALTER TABLE使用表锁。

### 行锁
&emsp;&emsp; 行锁可以最大程度支持并发处理，同时也带来了最大的锁开销。行锁只在存储引擎层实现，而MySQL服务层没有实现。

### 事务
&emsp;&emsp; 事务是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能成功对数据库应用该组查询的全部语句，那么执行该组查询。
如果有任何一条语句因为崩溃或其他原因不能执行，那么所有的语句都不会执行，也就是事务内的语句，要么全部成功，要么全部失败。
要么使用COMMIT提交事务修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。

    START TRANSACTION;
    ......
    COMMIT;
    
#### ACID
&emsp;&emsp; ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)。

    原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务要么所有操作执行完成，要么全部失败回滚。
    一致性: 数据库总是从一个一致性的状态转移到另一个一致性的状态。
    隔离性：通常来说，一个事务所做的修改在提交之前，对其他的事务是不可见的。
    持久性：一旦事务提交，那么修改将永久保存到数据库中，即使系统崩溃修改的数据也不会丢失。

### 隔离级别
&emsp;&emsp; 在SQL标准中定义了四种隔离级别：未提交读(READ UNCOMMITTED)、提交读(READ COMMITTED)、可重复读(REPEATABLE READ)、
可串行化(SERIALIZABLE)。
    
    未提交读：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。性能上来说，未提交读
            不会比其他级别好太多，但是缺乏其他级别的很多好处，一般实际应用中很少使用。
    
    提交读：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这种级别有时也叫不可重复读，因为两次执行同样的查询可能会得到不同的结果。
    
    可重复读：解决了脏读的问题。是MySQL默认隔离级别。保证了在一个事务中多次读取同样记录的结果是一致的。但是无法解决另一个幻读(Phantom Read)问题。
             幻读是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
             
    可串行化：是最高的隔离级别。通过强制事务串行化执行，避免了幻读问题。串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。
    
    隔离级别        脏读可能性       不可重复读可能性        幻读可能性       加锁读
    未提交读           是                是                   是           否
    提交读             否                是                   是           否 
    可重复读           否                否                   是           否
    可串行化           否                否                   否           是
    
### 死锁
&emsp;&emsp; 死锁是两个或多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。如果多个事务尝试以不同的顺序锁定资源时，
就可能会产生死锁。InnoDB处理死锁的办法是，将持有最少行级排他锁的事务进行回滚。

### 自动提交
&emsp;&emsp; MySQL默认使用自动提交，也就是如果不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作。
    
    // 查询是否自动提交
    SHOW VARIABLES LIKE 'AUTOCOMMIT';
    
    // 1表示启用，0表示禁用
    SET AUTOCOMMIT = 1;
    
    // 设置事务隔离级别
    SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
    
### 隐式和显式锁定
&emsp;&emsp; 在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁在同一时刻被释放。
InnoDB会根据隔离级别在需要的时候自动加锁，这是隐士锁定。InnoDB也支持通过特定的语句进行显式锁定。

    SELECT ... LOCK IN SHARE MODE
    SELECT ... FOR UPDATE
    
<br>
&emsp;&emsp; InnoDB支持LOCK TABLES和UNLOCK语句，这是在服务器层实现的，和存储引擎无关。建议除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，
其他任何时候都不要执行LOCK TABLES。

### 多版本并发控制(MVCC)
&emsp;&emsp; MVCC是行级锁的一个变种，在很多情况下避免了加锁操作，实现了非阻塞的读操作，写操作也之锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现，
不管执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不同的。
InnoDB通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存行的创建时间，另一个保存行的过期时间(或删除时间)，存储的并不是实际的时间值，
而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

    1，InnoDB只查找版本早于(<=)当前事务版本的数据行，这样可以确保事务读取的行要么是在事务开始前就存在的，要么是事务自身插入或修改的。
    2，行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行，在事务开始前未被删除。
    
<br>
&emsp;&emsp; 通过保存两个额外的系统版本号，可以使大多数读操作都不用加锁，但是每行记录都要额外的存储空间，要做更多的行检查，以及额外的维护。
MVCC只在REPEATABLE READ、READ COMMITTED两个隔离级别下工作。

&emsp;&emsp; 在文件系统中，MySQL将每个数据库(schema)保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件，
这个保存了表的定义。

    可以使用SHOW TABLE STATUS LIKE 'table_name'；来查看表相关的信息。
    
### InnoDB
&emsp;&emsp; InnoDB是MySQL默认事务型引擎，是使用最广泛的。InnoDB数据存储在表空间中(tablespace)，表空间是由InnoDB管理的一个黑盒子。

<h2 id="2">2.Schema与数据类型优化</h2>
&emsp;&emsp; MySQL支持的数据类型很多，通常选择类型遵循以下原则。
    
    1，更小的通常更好，应该尽量使用可以正确存储数据的最小数据类型。但要确保没有低估需要存储的值的范围，因为在schema中的多个地方增加数据类型的
        范围是一个非常耗时和痛苦的操作。
    2，简单就好，简单数据类型操作通常需要更少的CPU周期。整型比字符操作代价更低。例如：应该使用MySQL内建类型而不是字符串来存储日期和时间。
        应该用整型存储IP地址。
    3，尽量避免NULL，如果查询中包含为NULL的列，对于MySQL更难优化。因为可为NULL的列使索引、索引统计和值比较都更加复杂，可为NULL的列会使用更多的存储空间，
        在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。要尽量避免索引建在可为NULL的列。
        
<br>
&emsp;&emsp; DATETIME和TIMESTAMP都可以存储相同类型的数据，但是TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。
另一方面TIMESTAMP允许的时间范围要小很多。

### 整数类型
&emsp;&emsp; 有两种类型的数字：整数(whole number)和实数(real number)。如果存储整数，可以使用：TINYINT(8 bit)、SMALLINT(16 bit)、
MEDIUMINT(24 bit)、INT(32 bit)、BIGINT(64 bit)，它们可以存储的值的范围从-2^(N - 1)到 2^(N - 1) - 1，其中N是存储空间的位数。
整数计算一般使用64位的BIGINT。MySQL可以为整数类型指定宽度，例如INT(11)，它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数，
对于存储来说，INT(1)和INT(20)是一样的。

### 实数类型
&emsp;&emsp; 实数是带有小数部分的数字。FLOAT和DOUBLE支持使用标准的浮点运算进行近似计算。DECIMAL用于存储精确的小数，支持精确计算。
MySQL服务器自身实现了DECIMAL的高精度计算，CPU直接支持原生浮点计算，所以浮点运算明显更快。浮点和DECIMAL都可以指定精度，
对于DECIMAL可以指定小数点前后所允许的最大位数，这会影响列的空间消耗。DECIMAL只是一种存储格式，在计算中DECIMAL会转换为DOUBLE类型。

<br>
&emsp;&emsp; 有多种方法可以指定浮点列所需要的精度，这会使MySQL选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义是非标准的，
因此建议只指定数据类型，不指定精度。浮点类型在存储同样范围的值时，通常比DECIMAL使用更小的空间。FLOAT使用4个字节存储，DOUBLE使用8个字节存储。
因为DECIMAL需要额外的空间和计算开销，因此只在对小数进行精确计算时才使用DECIMAL。

### 字符串类型
&emsp;&emsp; VARCHAR和CHAR类型是最主要的字符串类型。VARCHAR在以下情况使用比较合适：1，字符串列最大长度比平均长度大很多，列更新很少，
所以碎片不是问题。2，使用了UTF-8这种复杂的字符集，每个字符都使用不同的字节数进行存储。InnoDB会把过长的VARCHAR存储为BLOB。

    VARCHAR：用于存储可变长字符串，是最常见的字符串数据类型。比定长类型更节省空间，有种例外，当MySQL表使用ROW_FORMAT=FIXED创建的话，
            每一行都会定长存储，这样会导致浪费空间。VARCHAR需要使用1或2个额外字节记录字符串的长度，长度小于等于255，使用1个字节记录长度。
            在UPDATE时，如果使行变得比原来更长，且页中没有更多的空间可以存储，这种情况下InnoDB需要分裂页来使行可以放进页中内。
    
    CHAR：CHAR类型是定长的，当存储CHAR值时，MySQL会删除所有的末尾空格。在存储格式上，CHAR值会根据需要采用空格进行填充以方便比较。
            CHAR不容易产生碎片。
            
<br>
&emsp;&emsp; 与CHAR、VARCHAR类似的还有BINARY、VARBINARY，它们存储的是二进制字符串。二进制字符串与常规字符串十分相似，但二进制字符串存储的
是字节码，而不是字符。MySQL填充BINARY采用的是\0而不是空格，在检索时也不会去掉填充值。二进制比较比字符比较简单很多，所以也更快。

### BLOB和TEXT类型
&emsp;&emsp; BLOB和TEXT都是为了存储很大数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。字符串类型为：TINYTEXT、SMALLTEXT、
TEXT、MEDIUMTEXT、LONGTEXT。二进制类型为：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。MySQL会把每个BLOB和TEXT值当作一个独立的对象处理，
存储引擎存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，
然后在外部存储区域存储实际的值。

    Memory引擎不支持BLOB和TEXT，所以如果查询使用了BLOB或TEXT列，并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，这会导致严重的性能开销。
    如果EXPLAIN执行计划的Extra列包含"Using temporary"，则说明这个查询使用了隐式临时表。
    
### 日期和时间类型
&emsp;&emsp; DATETIME能保存从1001年到9999年，精度为秒，把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节存储空间。
TIMESTAMP能保存从1970年1月1日以来的秒数，使用4个字节的存储空间，只能表示从1970年到2038年。尽量应该使用TIMESTAMP，比DATETIME空间效率更高。

### MySQL schema设计中的陷阱
&emsp;&emsp; 1，太多的列，MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。
如果定义了一个非常多列的表，然而只有一小部分会实际使用到，那么转换的代价就会非常高。2，太多的关联，MySQL限制每个关联操作最多只能有61张表，
如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。3，全能的枚举，防止过度使用枚举。4，变相的枚举。5，非此发明的NULL，
在确实需要NULL的时候，可以直接使用NULL，避免由于无意义的非空值导致的bug。

### 加快ALTER TABLE操作的速度
&emsp;&emsp; MySQL的ALTER TABLE操作性能对于大表来说是个大问题。MySQL执行大部分修改表结构操作的方法使用新的结构创建一个空表，
从旧表中查出所有的数据插入新表，然后删除旧表。对于常见的场景，可以使用的技巧有两种：1，先在一台不提供服务的机器上执行ALTER TABLE操作，
然后和提供服务的主库进行切换。2，影子拷贝，创建一张跟源表无关的新表，然后通过重命名和删表操作交换两张表。
    
    // 通过ALTER COLUMN来该表列的默认值，会直接修改.frm文件不涉及表数据，因此这个操作很快。
    ALTER COLUMN rental_duration SET DEFAULT 5; 

### 只修改.frm文件
&emsp;&emsp; 有些操作可能不需要重建表：1，移除一个列的AUTO_INCREMENT属性。2，增加、移除、或修改ENUM和SET常量，如果移除的是已经有行数据用到其值的常量，
那么查询会返回一个空字符串值。

    替换.frm文件步骤：
    1，创建一张有同样结构的空表，并进行所需要的修改。
    2，执行FLUSH TABLE WITH READ LOCK。这会关闭所有正在使用的表，并禁止任何表被打开。
    3，交换.frm文件。
    4，执行UNLOCK TABLES来释放第2步的读锁。
    
<h2 id="3">3.创建高性能的索引</h2>
&emsp;&emsp; 在MySQL中，存储引擎使用类似的方法使用索引，先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引是在存储引擎层
而不是服务器层实现的。

### B-Tree索引
&emsp;&emsp; 如果没有指明类型，那么一般说的索引是B-Tree索引，使用B-Tree数据结构来存储数据。InnoDB使用B+Tree。InnoDB根据主键引用被索引的行。

    如果不是按照索引的最左列开始查找，则无法使用索引。
    不能跳过索引中的列。
    如果查询中有某个列的范围查询，那么其右边所有的列都无法使用索引优化查找。如果范围查询列值的数量有限，那么可以用多个等于条件来代替范围条件。
    
    例如 (a, b) 联合索引。SELECT * FROM table WHERE a > 1 AND b = 2; 这里由于a使用了范围条件，因此b永远都不会用到索引，
    如果a条件优化器发现查询成本很高，会直接执行全表扫描，否则a还是会使用索引查询的。
    
    B-Tree对如下类型的查询有效：
    1，全值匹配，和索引中的所有列进行匹配。
    2，匹配最左前缀。即只使用索引的第一列。
    3，匹配列前缀。只配置某一列的值的开头部分。
    4，匹配范围值。使用索引的第一列，匹配范围值。
    5，精确匹配某一列并范围匹配另外一列。
    6，只访问索引的查询。即查询只需要访问索引，而无须访问数据行。
    
    B树：又叫平衡多路查找树，与平衡二叉树不同点：
        1，平衡二叉树最多有两个子树，而B树每个节点可以有多个子树，M阶B树，表示该树每个节点最多有M个子数。
        2，平衡二叉树每个节点只有一个数据和指向孩子的指针，而B树每个中间节点有K-1个关键字，和K个子树。
        3，B树的每个叶子节点在同一层，并且叶子节点只有关键字，指向孩子的指针为null。
        
    B+树：B+树是B树的升级版，相比于B树更充分利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分查找。
        1，B+树与B树不同，B+树非叶子节点不保存关键字记录的指针，只进行数据索引，这样B+树非叶子节点所能保存的关键字大大增加。
        2，B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，因此每次数据查询的次数都一样。
        3，B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
        4，非叶子节的子节点数 = 关键字数。
        
    InnoDB每个数据页默认为16kb，非叶子节点存放(key，pointer)，关键字bigint 8字节，页指针6字节，非叶子节点可以存16KB / 14B = 1170个。
    假设一个数据页16KB可以存16条数据，那么高度为2的B+树，可以存储 1170 * 16 = 18720条数据。

### 哈希索引
&emsp;&emsp; 哈希索引是将键转化为哈希值，利用哈希值定位数据。与B+树相比：1，在等值查找时具有绝对优势。2，哈希索引无法用于范围查询。
3，哈希索引没办法利用索引完成排序。4，哈希索引不支持最左匹配原则。5，在大量重复键重复情况下，由于哈希碰撞，哈希索引效率极低。
    
### 索引的优点
&emsp;&emsp; B-Tree索引按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。
    
    1，索引大大减少了服务器需要扫描的数据量。
    2，索引可以帮助服务器避免排序和临时表。
    3，索引可以将随机I／O变为顺序I／O。
    
### 高性能的索引策略
&emsp;&emsp; 高效的选择和使用索引有很多种方式。

    独立的列：索引不能是表达式的一部分，也不能是函数的参数。例如：SELECT actor_id FROM xxx WHERE actor_id + 1 = 5;
    前缀索引和索引选择性：索引的选择性是指不重复的索引值和数据表的记录总数(#T)的比值，范围从 1/#T到1。索引的选择性越高，查询效率越高。
            唯一索引的选择性为1，查询效率最好。对于BLOB、TEXT，或很长VARCHAR类型的列，必须使用前缀索引，前缀索引的选择性尽量应该接近索引整个列。
    多列索引：1，当出现服务器对多个索引做相交操作时(通常多个AND条件)，通常意味着需要一个包含所有相关列的多行索引，而不是多个独立的单列索引。
            2，当服务器需要对多个索引做联合操作时(通常多个OR条件)，通常需要耗费大量CPU和内存资源在算法的缓存、排序、合并操作上。
            3，优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。这会使查询成本被低估，导致该执行计划还不如直接走全表扫描。
            
<br>
&emsp;&emsp; 根据经验法则，当不需要考虑排序和分组时，将选择性最高的列放在前面是很好的。可能需要根据那些运行频率最高的查询来调整索引列的顺序。

### 聚簇索引
&emsp;&emsp; 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。在InnoDB中，聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
当表中有聚簇索引时，数据行实际上存放在索引的叶子页中，聚簇表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，
所以一个表只能有一个聚簇索引。InnoDB通过主键聚簇数据，如果没有定义主键，InnoDB会选择一个唯一的非空索引替代，如果没有这样的索引，
InnoDB会隐式的定义一个主键来作为聚簇索引。

    聚簇索引把索引和数据行放在一起，也就是都加载到内存中。
    聚簇数据优点：
        1，可以把相关数据放在一起。根据聚簇索引就能查询数据，避免磁盘IO。
        2，数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。
        3，使用覆盖索引扫描的查询，可以直接使用页节点中的主键值。
        
### InnoDB表中按主键顺序插入行
&emsp;&emsp; 最简单的是使用AUTO_INCREMENT自增列主键。这样每次都是从尾部插入数据，页满了后，会在新页中增加数据。如果是随机顺序插入，
如果要插入的页已经满了，那么将会进行页分裂，页分裂会导致移动大量数据，频繁的页分裂会使页变得稀疏并被不规则地填充，最终数据会有碎片。
在把这些随即值载入到聚簇索引后，也许需要做一次OPTIMIZE TABLE来重建表并优化页的填充。

    在使用InnoDB时应该尽可能地按主键顺序插入数据，并尽可能地使用单调增加的聚簇健的值来插入新行。
    
### 覆盖索引
&emsp;&emsp; 如果一个索引包含(或者说覆盖)所有需要查询的字段的值，那我们就称之为覆盖索引。当发起一个被索引覆盖的查询时(索引覆盖查询)，
EXPLAIN的EXTRA列可以看到"Using index"的信息。

    下列情况，执行计划不会使用覆盖查询：
        1，SELECT选择的字段中含有不在索引中的字段，即索引没有覆盖全部的列。
        2，WHERE条件中不能含有对索引进行LIKE的操作。
        
### 使用索引扫描来排序
&emsp;&emsp; MySQL中有两种方式可以生成有序的结果：1，通过排序操作。2，按索引顺序扫描。如果EXPLAIN的TYPE值为"index"，则说明MySQL使用了索引扫描来做排序。
MySQL可以使用同一个索引既满足排序又用于查找行，如果可能设计索引时应该尽可能地同时满足这两种任务。

    只有当索引的列顺序和ORDER BY子句顺序完全一致，并且所有列的排序方向(正序或倒序)都一样时，MySQL才能使用索引来对结果进行排序。
    
### 索引和锁
&emsp;&emsp; 索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。
但这需要InnoDB在存储引擎层能过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层后，
MySQL服务器才能应用WHERE子句，这时已经无法避免锁定行，InnoDB可以在服务器端过滤掉行后就释放锁，但旧版本只有事务提交后才能释放锁。

### 避免多个范围条件
&emsp;&emsp; 如果是多维度的范围查询，可以先把其中一个范围查询转化为一个简单的等值查询。

### 维护索引和表
&emsp;&emsp; 维护表主要有三个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。数据碎片可以通过OPTIMIZE TABLE或者导出再导入的方式
来重新整理数据。

    使用CHECK TABLE通常能找出大多数的表和索引的错误。可以使用REPAIRE TABLE命令来修复损坏的表。
    
    数据碎片有三种：
        1，行碎片，数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
        2，行间碎片，指逻辑上顺序的页或者行在磁盘上不是顺序存储的。
        3，剩余空间碎片，指数据页中有大量的空余空间。
        
<br>
&emsp;&emsp; 在选择索引和编写利用这些索引的查询时，有三个原则：1，当行访问是很慢的。如果服务器从存储中读取一个数据块，只是为了获取其中一行，
那么就浪费了很多工作。2，按顺序访问范围数据是很快的，有两个原因，第一，顺序I／O不需要多次磁盘寻道，所以比随机I／O快很多；第二，如果服务器能按照需要
顺序读取数据，那么就不用额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算。3，索引覆盖查询是很快的。

### 索引失效的情况

    1，查询条件使用不等式。
        SELECT * FROM table_a WHERE key_a <> '1';
    2，查询条件类型不一致。
        SELECT * FROM table_a WHERE key_a = 1;  // 此时key_a 类型为字符串，传入的条件值为数字类型。
    3，查询条件使用函数计算。
        SELECT * FROM table_a WHERE key_a + 1 = 1;
        SELECT * FROM table_a WHERE CHAR_LENGTH(key_a) = 1; // 函数计算会导致索引失效。
    4，模糊查询
        SELECT * FROM table_a WHERE key_a LIKE '3';
    
    // 对于复合索引 idx_keys(`key_a`, `key_b`, `key_c`)
    5，复合索引使用不等式。
        SELECT * FROM table_a WHERE key_a = '1' AND key_b = '2' AND key_c <> '3';  // 此时从key_c失效。
    6，复合索引查询条件类型不同，从不同的列开始索引失效。
        SELECT * FROM table_a WHERE key_a = '1' AND key_b = 2 AND key_c = '3';  // 此时从key_b开始，索引失效。
    
    7，单列索引不存储NULL值，复合索引不存储全为NULL的值。
        SELECT * FROM table_a WHERE key_a IS NULL; // 使用IS NULL时，不会使用索引。
    8，条件中有OR。
        SELECT * FROM table_a WHERE key_a = '1' OR key_b = '2'; // 此时想索引生效需要OR条件中，每个列都加上索引。

<h2 id="4">4.查询性能优化</h2>
&emsp;&emsp; 通常查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。
其中执行是整个生命周期中最重要的阶段，这其中包含了大量为了检索数据到存储引擎的调用，以及调用后的数据处理，包括排序、分组等。

    对于低效的查询，通过下面两个步骤分析总是很有效的：
        1，确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多列。
        2，确认MySQL服务器层是否在分析大量超过需要的数据行。
        
<br>
&emsp;&emsp; MySQL最简单的衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数。
    
    响应时间：服务时间 + 排队时间。服务时间是指数据库处理这个查询真正花了多长时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。
    
    理想情况下扫描的行数和返回的行数应该是相同的，但实际这种情况并不多。例如关联查询时，服务器必须要扫描多行才能生成结果集中的一行。
    扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间。
    
    EXPLAIN中的type列反应了访问类型。访问类型有很多种：全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度从慢到快。
    
### 分解关联查询
&emsp;&emsp; 很多高性能的应用都会对关联查询进行分解。
    
    分解关联查询优势：1，让缓存更高效。2，查询分解后，执行单个查询能减少锁的竞争。3，在应用层做关联，更容易对数据库进行拆分，更容易做到高性能和可扩展。
        4，查询本身的效率也可能会有所提升，有时，使用IN代替关联查询更高效。5，可以减少冗余记录的查询。6，这样做相当于在应用中实现了哈希关联，
        而不是使用MySQL的嵌套循环关联。
        
### 查询执行的基础
&emsp;&emsp; MySQL执行查询的过程。
    
    1，客户端发送一条查询给服务器。
    2，服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段。
    3，服务器端进行MySQL解析、预处理，再由优化器生成对应的执行计划。
    4，MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
    5，将结果返回给客户端。
    
<br>
&emsp;&emsp; 对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，该状态表明MySQL当前正在做什么。使用SHOW FULL PROCRSSLIST命令能够查看当前状态。
    
    Sleep：线程正在等待客户端发送新的请求。
    Query：线程正在执行查询或者正在将结果发送给客户端。
    Locked：在MySQL服务器层，表明线程正在等待表锁。
    Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。
    Copying to tmp table：线程正在执行查询，并且将结果集复制到一个临时表中，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，
            或者是UNION操作。如果这个状态后面还有"on disk"标记，那表示MySQL正在将一个内存临时表放到磁盘上。
    Sorting result：线程正在对结果进行排序。
    Sending data：可能表示多种情况：1，线程可能在多个状态之间传送数据。2，正在生成结果集。2，向客户端返回数据。
    
### 查询优化处理
&emsp;&emsp; 查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎交互。包括：解析SQL、预处理、优化SQL执行计划。
    
    语法解析器和预处理：MySQL通过关键字将SQL语句进行解析，并生成一棵对应的解析树。MySQL解析起将使用MySQL语法规则验证和解析查询。
    查询优化器：优化器将语法树转换成执行计划。优化器作用是找到最好的执行计划。MySQl使用基于成本的优化器，尝试预测一个查询使用某种执行计划时的成本，
        并选择其中成本最小的一个。

<br>
&emsp;&emsp; 优化器策略分两种：1，静态优化。2，动态优化。静态优化可以直接对解析树进行分析，并完成优化。动态优化与查询上下文有关，需要在每次查询时都重新评估。
MySQL对查询的静态优化只需要做一次。

    MySQL能够处理的优化类型：
        1，重新定义关联表的顺序。决定关联的顺序是优化器很重要的一部分功能。
        2，将外连接转换为内连接。如果WHERE条件、库表结构能让外连接等价于一个内连接。MySQL能够识别并重写查询条件，让其调整关联顺序。
        3，使用等价交换规则。MySQL可以使用一些等价交换来简化并规范表达式。例如 5 = 5 AND a > 5 将被改写成 a > 5。
        4，优化COUNT()、MIN()、MAX()。索引和列是否可为空通常可以帮助MySQL优化这类表达式。
        5，预估并转化为常数表达式。当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。
        6，覆盖索引扫描。当索引中的列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无须查询对应的数据行。
        7，子查询优化。MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。
        8，提前终止查询。在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。
        9，等值传播。如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一列上。
        10，列表IN()的比较。在MySQL中，将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件。
            这是一个O(log n)复杂度的操作，等价地转换成OR的查询复杂度为O(n)，对于IN()列表中有大量取值的时候，MySQL更快。
            
### 数据和索引的统计信息
&emsp;&emsp; MySQL在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息是由存储引擎实现的，不同的存储引擎可能存储不同的统计信息。
MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取响应的统计信息。存储引擎提供给优化器对应的统计信息，包括：每个表或者索引有多少个页面，
每个表的每个索引的基数是多少，数据行和索引长度、索引的分布信息等。优化器根据这些信息选择一个最优的执行计划。

### MySQL如何执行关联计划
&emsp;&emsp; MySQL中每一个查询都是一次关联。对于UNION查询，MySQL先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成
UNION查询。MySQL对于任何关联都执行嵌套循环关联操作，即MySQL现在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，
直到找到所有表中匹配的行为止。MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行后，MySQL返回到上一层次关联表，
看是否能够找到更多的匹配记录，依次类推迭代执行。

    // USING(col3) == ON tbl1.col3 = tbl2.col3
    // 使用INNER JOIN关联查询
    SELECT tbl1.col1, tbl2.col2
    FROM tbl1 INNER JOIN tbl2 USING(col3)
    WHERE tbl1.col1 IN (5, 6);
    
    // 上面的MySQL查询可以使用下面伪代码表示，也就是先根据左侧的where找到临时集合，然后通过循环这个集合中的元素，在JOIN中找到对应的行。
    outer_iter = iterator over tbl1 where col1 IN (5, 6)
    outer_raw = outer_iter.next
    while outer_raw
        inner_iter = iterator over tbl2 where col3 = outer_raw.col3
        inner_raw = inner_iter.next
        while inner_raw
            output [outer_raw.col1, inner_raw.col2]
            inner_raw = inner_iter.next
        end
        outer_raw = outer_iter.next
    end
    
    // 使用OUTER JOIN关联查询
    SELECT tbl1.col1, tbl2.col2
    FROM tbl1 LEFT OUTER JOIN tbl2 USING(col3)
    WHERE tbl1.col1 IN (5, 6);
    
    // 上面的伪代码表示为：
    outer_iter = iterator over tbl1 where col1 IN (5, 6)
    outer_raw = outer_iter.next
    while outer_raw
        inner_iter = iterator over tbl2 where col3 = other_raw.col3
        inne_raw = inner_iter.next
        if inner_raw
            while inner_raw
                output [outer_raw.col1, inner_raw.col2]
                inner_raw = inner_iter.next
            end
        else
            output [outer_raw.col1, NULL]
        end
        outer_raw = outer_iter.next
    end
    
<br>
&emsp;&emsp; MySQL在FROM子句中遇到子查询时，先执行子查询并将结果放到一个临时表中，然后将这个临时表当作一个普通表对待。MySQL在使用UNION时，
也使用类似的临时表，在遇到右外连接时，MySQL将其改写成等价的左外连接。

### 执行计划
&emsp;&emsp; MySQL不会生成查询字节码来执行查询，MySQL生成查询的一棵指令树，然后通过存储引擎执行完成这颗指令树并返回结果。
如果对某个查询执行EXPLAIN EXTENDED 后，再执行SHOW WARNINGS，就可以看到重构出的查询。

### 关联查询优化器
&emsp;&emsp; MySQL优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序。多表关联的时候，可以有多种不同的关联顺序来获取相同
的执行结果。关联查询优化器通过评估不同顺序时的成本来选择一个代价最小的关联顺序。可以使用STRAIGHT_JOIN关键子重写查询，让优化器按照你认为最优
的关联顺序执行。
    
    如果N个表关联，那么需要检查N的阶乘种关联顺序，我们称之为所有可能的执行计划的搜索空间。当搜索空间非常大的时候，不会逐一评估每种关联顺序的成本，
    这时候使用贪婪搜索方式查找最优关联顺序。

### 排序优化
&emsp;&emsp; 排序是一个成本很高的操作，应该尽量避免排序或对大量数据进行排序。当不能使用索引生成排序结果时，MySQL需要自己进行排序，
如果数量小则在内存中进行，如果数量大则需要使用磁盘，MySQL将这个过程统一称为文件排序(filesort)。如果排序数量小于排序缓冲区，
那么MySQL使用快速排序，如果内存不够，那么MySQL先将数据分块，然后对每个独立的快速排序，然后将各个块排序结果放在磁盘上，然后对排序好的块进行合并，
最后返回排序结果。如果查询中有LIMIT，那么LIMIT会在排序后应用。如果使用了LIMIT，那么MySQL不再对所有的结果进行排序，而是根据实际情况，
选择抛弃不满足条件的结果，然后排序。

    1，如果ORDER BY子句中的所有列都来自关联的第一个表，那么MySQL在关联处理第一个表的时候就进行文本排序。
        这种情况EXPLAIN结果的Extra会有"Using filesort"。
    2，除此之外所有情况，MySQL都会将关联的结果放到一个临时表中，然后在所有关联都结束后，再进行文件排序。
        这种情况EXPLAIN结果的Extra可以看到"Using temporary; Using filesort"。
        
### 查询执行引擎
&emsp;&emsp; 在查询执行阶段，MySQL只是简单的根据执行计划给出指令逐步执行，在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎
实现的接口来完成，这些接口也就是我们称为handler API的接口。查询中每一个表由一个handler的实例表示，MySQL在优化阶段为每个表创建了一个handler实例，
优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名、索引统计信息等。

    存储引擎有非常丰富的功能，但是底层接口却只有几十个，这些接口像搭积木一样能够完成查询的大部分功能。
    
### 返回结果给客户端
&emsp;&emsp; MySQL将结果集返回给客户端是一个增量、逐步返回的过程。例如：前面的关联操作，一旦服务器完成最后一个关联表，开始生成第一条结果时，
MySQL就可以开始向客户端逐步返回结果集了。这样有两个好处：1，服务器端无须存储太多结果，也不会因为返回太多结果消耗太多内存。2，这种处理可以让
MySQL客户端第一时间获得返回的结果。

### MySQL查询优化器的局限性
#### 关联子查询
&emsp;&emsp; MySQL关联子查询实现得很糟糕，最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。通常可以使用JOIN关联来优化或者使用
EXISTS()等效的改写查询来获取更好的效率。子查询有时候会比关联查询快，需要用测试来验证。EXPLAIN后，相关子查询的select_type为DEPENDENT SUBQUERY。

    // 我们通常认为下面这个SQL，会先执行IN里面的子查询，再执行外层查询，如：SELECT * FROM film WHERE film_id IN (1...);
    SELECT * FROM film
    WHERE film_id IN (SELECT film_id FROM film_actor WHERE actor_id = 1);
    
    // 实际上MySQL会将相关的外层表压到子查询中。MySQL会将查询改写成下面SQL。这样会导致先全表扫描film，返回film_id，根据film_id逐个执行
    // 子查询，如果film表比较大，那么查询性能会很糟糕。
    SELECT * FROM film
    WHERE EXISTS (SELECT * FROM film_actor WHERE actor_id = 1 AND film_actor.film_id = film.film_id);
    
#### UNION的限制
&emsp;&emsp; 如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望能够先排好序再合并结果集的话，就需要在UNION的各个子句中分别
使用这些子句。如果想获得正确的顺序，那么还需要加上一个全局的ORDER BY和LIMIT操作。

    (SELECT first_name, last_name FROM actor ORDER BY last_name LIMIT 20) UNION ALL
    (SELECT first_name, last_name FROM customer ORDER BY last_name LIMIT 20) LIMIT 20;
    
### 查询优化器的提示(hint)
&emsp;&emsp; 如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示(hint)来控制最终的执行计划。

    HIGH_PRIORITY和LOW_PRIORITY：HIGH_PRIORITY用于SELECT语句的时候，MySQL会将此SELECT语句重新调度到所有正在等待表锁以便修改数据的语句之前。
        HIGH_PRIORITY还可以用于INSERT语句，其效果只是简单的抵消了全局LOW_PRIORITY设置对该语句的影响。LOW_PRIORITY会让语句一致处于等待状态，
        只要队列中还有访问同一个表的语句。LOW_PRIORITY在SELECT、INSERT、UPDATE、DELETE中都能使用。这两个提示只对使用表锁的存储引擎有效，
        千万不要在InnoDB或其他有细粒度锁机制和并发控制的引擎中使用，因为这两个会导致并发插入被禁止，可能严重降低性能。
        
    DELAYED：只对INSERT和REPLACE有效。MySQL会将使用该提示的语句立即返回给客户端，并将插入的行数据放入到缓冲区，然后在表空闲时批量写入。
        这个提示会导致函数LAST_INSERT_ID()无法正常工作。
        
    STRAIGHT_JOIN: 第一个用法是让查询中所有关联的表按照语句中出现的顺序进行关联。第二个用法是固定其前后两个表的关联顺序。
    
    SQL_SMALL_RESULT和SQL_BIG_RESULT：这两个提示只对SELECT语句有效，告诉优化器对GROUP_BY或者DISTINCT查询如何使用临时表及排序。
        SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果放在内存中的索引临时表，以避免排序操作，如果是SQL_BIG_RESULT则告诉优化器
        结果集可能很大，建议使用磁盘临时表做排序操作。
    
    SQL_BUFFER_RESULT：告诉优化器将查询结果放入到一个临时表，然后尽可能快的释放表锁。这样无须在客户端上消耗太多内存，
        但是服务器端需要更多内存。
    
    SQL_CACHE和SQL_NO_CACHE：告诉MySQL结果集是否应该缓存在查询缓存中。
    
    SQL_CALC_FOUND_ROWS: 并不是一个优化器提示，不会告诉优化器任何关于执行计划的东西。会让MySQL返回的结果集包含更多的信息。查询加上该提示
        MySQL会计算除去LIMIT子句后这个查询要返回的结果集总数。可以使用FOUND_RAW()获取这个值。
        
    FOR UPDATE和LOCK IN SHARE MODE：也不是真正的优化器提示，主要控制SELECT语句的锁机制，只对实现了行锁的存储引擎有效。该提示会对符合
        查询条件的数据行加锁。唯一内置的支持这两个提示的引擎就是InnoDB，这两个提示经常被滥用，容易造成服务器的锁争用问题，
        应该尽量避免使用这两个提示，通常有其他更好的方式可以实现同样的目的。
        
    USING INDEX、IGNORE INDEX和FORCE INDEX：这几个提示告诉优化器使用或者不使用哪些索引来查询记录。FORCE INDEX和USING INDEX基本相同，
        除了FORCE INDEX会告诉优化器全表扫描的成本会远远高于索引扫描，哪怕实际上该索引用处不大。当发现优化器选择了错误的索引，
        或者因为某些原因要使用另一个索引时，可以使用该提示。
    
    // 在MySQL5.0和更新版本中，增加了一些参数来控制优化器的行为。
    optimizer_search_depth: 这个参数控制优化器在穷举执行计划时的限度。如果查询长时间处于"Statistics"状态，那么可以考虑调低此参数。
    
    optimizer_prune_level: 该参数默认是打开的，让优化器会根据需要扫描的行数来决定是否跳过某些执行计划。
    
    optimizer_switch: 这个变量包含了一些开启/关闭优化器特性的标志位。
    
### 优化COUNT()查询
&emsp;&emsp; COUNT()是一个特殊的函数，有两种不同的作用：可以统计某个列值的数量，也可以统计行数。在统计列值时，要求列值是非空的，
如果执行了列或者列的表达式，那么统计的就是这个表达式有值的结果数。在使用COUNT(*)时，通配符不会扩展成所有列，实际上忽略所有列直接统计所有行数。
如果希望统计结果集的行数，最好使用COUNT(*)。

<h2 id="5">5.MySQL高级特性</h2>
### 分区表
&emsp;&emsp; 对于用户来说，分区表是一个独立的逻辑表，底层是由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象(Handler Object)的封装。
MySQL实现分区的方式--对底层表的封装，意味着索引也是按照分区的子表定义的，没有全局索引。每个操作都会先打开并锁住所有底层表，但并不是分区表在
处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁，则会在分区层释放对应的表锁，这个加锁和解锁过程与普通InnoDB上的查询类似。

    分区表也有一些限制：
    1，一个表最多只能有1024个分区。
    2，在MySQL中，分区表达式必须是整数，或者是返回整数的表达式。某些场景中可以直接使用列来进行分区。
    3，如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
    4，分区表中无法使用外键约束。
    
    SELECT查询
        当查询一个分区表时，分区表先打开并锁住所有的底层表，优化器判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据。
    INSERT操作
        当写入一条记录时，分区层先打开并锁住所有底层表，然后再确认哪个分区接收这条记录，再将记录写入对应底层表。
    DELETE操作
        当删除一条记录时，分区先打开并锁住所有底层表，然后确定数据对应的分区，最后对相应底层进行删除操作。
    UPDATE操作
        当更新一条记录时，分区先打开并锁住所有的底层表，MySQL先确定需要更新的记录在哪个分区，然后取出数据并更新，再判断更新后的记录应该放在
        哪个分区，最后对底层表进行写入操作，并对原数据所在的底层表进行删除操作。
        
<br>
&emsp;&emsp; MySQL支持多种分区表，最多的是根据范围进行分区，还支持键值、哈希和列表分区。

    分区技术包括：
    1，使用键值进行分区，减少InnoDB的互斥量竞争。
    2，使用数据模函数进行分区，将数据轮询放入不同的分区。例如多日期做模7的运算。
    3，假设表有一个自增的主键id，希望根据时间将最近的热点数据几种存放。可以使用HSAH(id DIV 1000000)，将为100万数据建立一个分区。
    
### 外键约束
&emsp;&emsp; InnoDB强制外键使用索引，外键通常要求每次在修改数据时都要在另一张表中多执行一次查找操作。如果外键列的选择性很低，
那么会导致一个非常大且选择性很低的索引。外键的约束使得查询需要额外访问一些别的表，这意味着需要额外的锁。有时可以使用触发器来代替外键，
对于相关数据的更新外键更合适，但是如果外键只是用作数值约束，那么触发器或者显式地限制取值会更好。如果只是使用外键做约束，那通常在应用程序里
实现该约束更好。

<h2 id="6">6.MySQL锁</h2>
&emsp;&emsp; MySQL锁分为表锁、行锁、页锁。

### 表锁
&emsp;&emsp; 表锁是对一整张表加锁，一般是DDL处理时使用。表锁由MySQL Server实现。表锁种类：读锁、写锁。
表锁特点：开销小、加锁快、无死锁、锁粒度大，发生锁冲突的概率高，并发性低。

### 表锁上锁/解锁
&emsp;&emsp; 上锁方式：1，隐式上锁(默认，自动加锁自动释放)，读锁：select。写锁：insert、update、delete。2，显式上锁。xiao.base.lock table tableName read/write;
解锁方式：1，解锁单表：unlock table tableName; 2，解锁所有表: unlock tables;

### 表锁问题排查
&emsp;&emsp; 查看表锁情况：SHOW OPEN TABLES; 表锁分析：SHOW STATUS LIKE 'table%'; 
table_locks_immediate：表示可以立即获取锁的次数。table_locks_waited：表示不能立即获取锁，需要等待锁的次数。

### 行锁
&emsp;&emsp; 行锁是对表中一行或多行进行加锁，自动加锁。一般在UPDATE、INSERT、DELETE、SELECT...FOR UPDATE时会加排他锁。行锁由存储引擎实现。
行锁种类：共享锁(读锁)、排他锁(写锁)、意向排他锁(IX)、意向共享锁(IS)。行锁特点：开销大、加锁慢、会出现死锁、锁粒度小，发生冲突的概率低，并发度最高。

### 行锁上锁/解锁
&emsp;&emsp; 隐式上锁：select(读锁)，update、insert、delete(写锁)。显式上锁：SELECT...LOCK IN SHARE MODE(共享锁)，SELECT...FOR UPDATE(排他锁)。
解锁：提交事务(COMMIT)、回滚事务(ROLLBACK)、kill阻塞进程。

### 行锁问题排查
&emsp;&emsp; 查询语句：SHOW STATUS LIKE 'innodb_row_lock%'; innodb_row_lock_current_waits表示当前正在等待锁定的数量。
innodb_row_lock_time表示从系统启动到现在锁定的总时间长度。innodb_row_lock_time_avg表示每次等待锁花平均时间。
innodb_row_lock_time_max表示从系统启动到现在等待最长的一次锁花费的时间。innodb_row_lock_waits表示从系统启动到现在总共等待的次数。

### 行锁优化
&emsp;&emsp; InnoDB支持表锁和行锁，在使用索引作为检索条件修改数据时采用行锁，否则采用表锁。有时索引并未被使用，此时会导致行锁升级为表锁，
因此排查时需要执行计划查询索引是否被实际使用。当事务涉及多个表，可能引起死锁，造成大量的事务回滚。这种情况若能一次性锁定涉及的表，可以避免死锁、
减少数据库因事务回滚带来的开销。当表的大部分数据都要被修改或者多表复杂关联查询时，建议使用表锁优于行锁。

    优化策略：
    1，尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
    2，合理设计索引，尽量缩小锁的范围。
    3，尽可能较少检索条件，避免间隙锁。
    4，尽量控制事务的大小，减少锁定资源量和时间长度。
    5，尽可能低级别事务隔离。
    
### 行锁的实现算法
&emsp;&emsp; Record Lock(行锁)：单个记录上的锁，Record Lock总会锁住索引记录，如果InnoDB建立的时候没有设置一个索引，
这时InnoDB会使用隐式的主键来进行锁定。Gap Lock(间隙锁)：当我们使用范围条件而不是相等条件时检索数据，并请求共享或排他锁时，
InnoDB会给符合条件的已有记录的索引加锁，对于键值在条件范围内，但是并不存在的记录。Gap Lock解决了事务并发的幻读问题。
Next-Key Lock：同时锁住数据 + 间隙锁。Repeatable Read隔离级别下，Next-Key Lock算法是默认的行记录锁定算法。

    Record Lock、Gap xiao.base.lock、Next-key Lock都是加在索引上的，如果有记录1、3、5、7，则5上的记录锁会锁住5，5上的gap lock会锁住(3, 5)，
    5上的next-key lock会锁住(3, 5]。

    
### 死锁解决方式
&emsp;&emsp; 两个或者个多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象，叫做死锁。
避免方式：1，加锁顺序一致，尽可能一次性锁定所需的数据行。2，尽量基于主键或者唯一索引更新数据。3，单次操作数据量不宜太多，涉及表尽量少。
4，减少表上索引，减少锁定资源。5，尽量使用较低的隔离级别。尽量使用相同条件访问数据，这样可以避免间隙锁对并发的插入影响。6，精心设计索引，
尽量使用索引访问数据。

### 共享锁、排他锁、意向共享锁、意向排他锁
&emsp;&emsp; 共享锁(S锁)：针对同一份数据，多个读操作可以同时进行，但是不能进行写入。排他锁(X锁)：当前操作完成前，会阻塞其他读和写操作。
意向共享锁(IS): 一个事务给一个数据行加共享锁时，必须先获得表的IS锁。意向排他锁(IX): 一个事务给一个数据行加排他锁时，必须先获得该表的IX锁。

<h2 id="7">7.MySQL数据页存储与磁盘之间的关系</h2>
&emsp;&emsp; 在InnoDB引擎中，所有数据都被逻辑的存放在表空间中，表空间(tablespace)是存储引擎中最高的存储逻辑单位，
在表空间的下面又包含：段(segment)、区(extend)、页(page)。在同一个数据库实例中，所有的表空间都有相同的页大小，默认情况下表空间大小为16KB。


    tablespace -----> segment -----> extend -----> page -----> raw
               1    N         1    N        1    N      1    N

### 数据读取
&emsp;&emsp; 实际上单次从磁盘中读取的单位是页而不是行，也就是说即使只读取一行记录，从磁盘中也是会读取一页的。

    sql ---> DB ---> 缓冲池 ---> 磁盘缓冲 -------> 磁盘
                                        读取一页

&emsp;&emsp; 关系型数据库最重要的一个目标就是，确保表或者索引中的数据是随时可以用的，那么为了尽可能的实现这个目标，会使用内存中的缓冲池来最小化磁盘活动。
每个缓冲池都足够大，可以存放成千上万页。如果在缓冲池中没有找到数据，那么会从磁盘服务器的缓冲区中读取，这个读取成本大概是1ms，
如果磁盘服务器中依然没有找到数据，那么需要从磁盘中读取，此时读取分为随机读取和顺序读取。

### 随机读取
&emsp;&emsp; 读取一个页需要一次随机IO，大概需要10ms的时间。

    排队----> 寻道 -----> 半圈旋转 -----> 传输 
    3ms       4ms          2ms          1ms

### 顺序读取
&emsp;&emsp; 如果按顺序读取，速度很快：1，磁盘不需要来回做机械运动。2，可以充分利用磁盘预读，比如在请求一页时，可以把后面几页数据也一起返回。
3，在一次查询中，每一页只会从磁盘中读取一次，读取数据后会放在缓冲池中，此时不需要再次从磁盘中读取。此时读取4kb的页所花费的时间大概是0.1ms。

    顺序读取情况：
    1，全表扫描。
    2，全索引扫描。
    3，索引片扫描。
    4，通过聚族索引扫描。
    
<h2 id="8">8.聚合查询</h2>
### MySQL常用聚合函数
&emsp;&emsp; 聚合函数，如果指定DISTINCT关键字，表示取消指定列中的重复值，如果不指定或者指定ALL，那么不会取消重复值。除了函数COUNT(*)外，
其他聚合函数，包括COUNT(<列名>)都会忽略空值。
    
    AVG、COUNT、GROUP_CONCAT、MAX、MIN、SUM、

### 分组聚合查询
&emsp;&emsp; 在分组聚合查询时，条件表达式需要放在HAVING中。GROUP BY 对查询结果按照字段列表进行分组，HAVING短语对分组的结果进行过滤，
仅输出满足条件的组。WHERE是在分组前筛选，HAVING是在分组后的数据组内再筛选。

    [GROUP BY 字段列表][HAVING <条件表达式>]
    
    例如：SELECT 
            user_role, AVG(salary) 
         FROM 
            employees 
        WHERE 
            user_age > 30
        GROUP BY
            user_role
        HAVING
            AVG(salary) > 1000;
    
<h2 id="9">9.MySQL主备同步</h2>
&emsp;&emsp; MySQL主从同步事件有三种形式：statement、row、mixed。statement：将对数据库操作的sql语句写入到binlog(binary-log)中；
row: 将每一条数据的变化写入到binlog中。mixed：statement和row的混合，MySQL决定什么时候写statement格式或row格式。
MySQL主备同步涉及到三个线程：1，主节点线程：log dump xiao.base.thread。2，从节点I/O线程。3，从节点SQL线程。

    1，当从节点执行start slave明令后，从节点创建一个I/O线程来连接主节点，接收Binlog并解析到各类Events后记录到从服务器本地文件，
        这个文件就是relay log(中继文件)。
    2，主节点接收到从节点的I/O请求后，主节点会为其创建一个log dump线程，用于发送和读取Binlog，在读取Binlog时，
        log dump线程会对主节点的Binlog加锁，直到读取完成。主节点会为每一个从节点创建一个log dump线程。
    3，从服务器创建SQL线程读取relay log内容，并应用于从服务器，从而使从服务器和主服务器的数据一致。中继文件充当缓冲区。

### 主从数据丢失
&emsp;&emsp; 主从同步默认使用异步复制，但如果Binlog还没复制给从服务器，此时主服务器宕机，会导致Binlog中的部分数据在从服务器中缺失。
MySQL还可以使用半同步复制，主服务器写入Binlog后，会强制立即将数据同步给从服务器，主服务器接收到至少一个ack就会认为操作完成，
这样即使主服务器宕机也能保证至少有一个从服务器中的数据是完整的。

<h2 id="10">10.数据库范式</h2>
&emsp;&emsp; 第一范式：要求属性具有原子性，不可再分解。第二范：要求记录具有唯一性，即实体的唯一性，不存在部分依赖。
第三范式：要求字段没有冗余，不存在依赖传递，要求任何字段都不能由其他字段派生出来。

    违反第二范式可能出现的问题：数据冗余：每条记录有同样的信息。删除、插入、更新异常：一旦改变数据，需要全部更改。
    例：学号、课程号、姓名、课程学分。此时课程学分依赖课程号，姓名依赖学号。
    
